CWE-ID,Name,Weakness Abstraction,Status,Description,Extended Description,Related Weaknesses,Weakness Ordinalities,Applicable Platforms,Background Details,Alternate Terms,Modes Of Introduction,Exploitation Factors,Likelihood of Exploit,Common Consequences,Detection Methods,Potential Mitigations,Observed Examples,Functional Areas,Affected Resources,Taxonomy Mappings,Related Attack Patterns,Notes
203,"Observable Discrepancy",Base,Incomplete,"The product behaves differently or sends different responses under different circumstances in a way that is observable to an unauthorized actor, which exposes security-relevant information about the state of the product, such as whether a particular operation was successful or not.","Discrepancies can take many forms and include things like responses, timing, control flow, or general behavior. These discrepancies can reveal information about the product's operation or internal state to an unauthorized actor. In some cases, discrepancies can be used by attackers to form a side channel.",::NATURE:ChildOf:CWE ID:200:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:200:VIEW ID:1003:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Technology-Independent:TECHNOLOGY PREVALENCE:Undetermined::,"","::TERM:Side Channel Attack:DESCRIPTION:Observable Discrepancies are at the root of class of attacks known as side channel attacks.::","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Confidentiality:SCOPE:Access Control:IMPACT:Read Application Data:IMPACT:Bypass Protection Mechanism:NOTE:An attacker can gain access to sensitive information about the system, including authentication information that may allow an attacker to gain access to the system.::SCOPE:Confidentiality:IMPACT:Read Application Data:NOTE:Crypto primitives being vulnerable to side-channel-attacks could render the supposedly encrypted data unencrypted plaintext in the worst case. This would compromise any security property.::","","::PHASE:Architecture and Design:STRATEGY:Separation of Privilege:DESCRIPTION:Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.::PHASE:Implementation:DESCRIPTION:Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages - but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not.::","::REFERENCE:CVE-2002-2094:DESCRIPTION:This, and others, use .. attacks and monitor error responses, so there is overlap with directory traversal.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-2094::REFERENCE:CVE-2001-1483:DESCRIPTION:Enumeration of valid usernames based on inconsistent responses:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-1483::REFERENCE:CVE-2001-1528:DESCRIPTION:Account number enumeration via inconsistent responses.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-1528::REFERENCE:CVE-2004-2150:DESCRIPTION:User enumeration via discrepancies in error messages.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-2150::REFERENCE:CVE-2005-1650:DESCRIPTION:User enumeration via discrepancies in error messages.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1650::REFERENCE:CVE-2004-0294:DESCRIPTION:Bulletin Board displays different error messages when a user exists or not, which makes it easier for remote attackers to identify valid users and conduct a brute force password guessing attack.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0294::REFERENCE:CVE-2004-0243:DESCRIPTION:Operating System, when direct remote login is disabled, displays a different message if the password is correct, which allows remote attackers to guess the password via brute force methods.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0243::REFERENCE:CVE-2002-0514:DESCRIPTION:Product allows remote attackers to determine if a port is being filtered because the response packet TTL is different than the default TTL.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0514::REFERENCE:CVE-2002-0515:DESCRIPTION:Product sets a different TTL when a port is being filtered than when it is not being filtered, which allows remote attackers to identify filtered ports by comparing TTLs.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0515::REFERENCE:CVE-2002-0208:DESCRIPTION:Product modifies TCP/IP stack and ICMP error messages in unusual ways that show the product is in use.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0208::REFERENCE:CVE-2004-2252:DESCRIPTION:Behavioral infoleak by responding to SYN-FIN packets.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-2252::REFERENCE:CVE-2001-1387:DESCRIPTION:Product may generate different responses than specified by the administrator, possibly leading to an information leak.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-1387::REFERENCE:CVE-2004-0778:DESCRIPTION:Version control system allows remote attackers to determine the existence of arbitrary files and directories via the -X command for an alternate history file, which causes different error messages to be returned.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0778::REFERENCE:CVE-2004-1428:DESCRIPTION:FTP server generates an error message if the user name does not exist instead of prompting for a password, which allows remote attackers to determine valid usernames.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1428::REFERENCE:CVE-2003-0078:DESCRIPTION:SSL implementation does not perform a MAC computation if an incorrect block cipher padding is used, which causes an information leak (timing discrepancy) that may make it easier to launch cryptographic attacks that rely on distinguishing between padding and MAC verification errors, possibly leading to extraction of the original plaintext, aka the Vaudenay timing attack.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0078::REFERENCE:CVE-2000-1117:DESCRIPTION:Virtual machine allows malicious web site operators to determine the existence of files on the client by measuring delays in the execution of the getSystemResource method.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2000-1117::REFERENCE:CVE-2003-0637:DESCRIPTION:Product uses a shorter timeout for a non-existent user than a valid user, which makes it easier for remote attackers to guess usernames and conduct brute force password guessing.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0637::REFERENCE:CVE-2003-0190:DESCRIPTION:Product immediately sends an error message when a user does not exist, which allows remote attackers to determine valid usernames via a timing attack.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0190::REFERENCE:CVE-2004-1602:DESCRIPTION:FTP server responds in a different amount of time when a given username exists, which allows remote attackers to identify valid usernames by timing the server response.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1602::REFERENCE:CVE-2005-0918:DESCRIPTION:Browser allows remote attackers to determine the existence of arbitrary files by setting the src property to the target filename and using Javascript to determine if the web page immediately stops loading, which indicates whether the file exists or not.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0918::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Discrepancy Information Leaks::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A6:ENTRY NAME:Information Leakage and Improper Error Handling:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A7:ENTRY NAME:Improper Error Handling:MAPPING FIT:CWE More Specific::",,"",
226,"Sensitive Information Uncleared in Resource Before Release for Reuse",Base,Draft,"The product prepares to release a resource such as memory or a file so that the resource can be reused by other entities, but the product does not fully clear previously-used sensitive information from that resource before the resource is released.","When resources are released, they can be made available to other parties for reuse. For example, after memory is used and released, an operating system may make the memory available to another process, or disk space may be reallocated when a file is deleted. It is not necessarily guaranteed that the operating system will re-initialize the resource or otherwise remove the original contents. Even when the resource is reused by the same process, this weakness can arise when new data is not as large as the old data, which leaves portions of the old data still available. Equivalent errors can occur in other situations where the length of data is variable but the associated data structure is not. If memory is not cleared after use, it may allow unintended actors to read the data when the memory is reallocated.",::NATURE:ChildOf:CWE ID:459:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:212:VIEW ID:1000::NATURE:CanPrecede:CWE ID:201:VIEW ID:1000::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Technology-Independent:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Confidentiality:IMPACT:Read Application Data::","","","::REFERENCE:CVE-2003-0001:DESCRIPTION:Ethernet NIC drivers do not pad frames with null bytes, leading to infoleak from malformed packets.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0001::REFERENCE:CVE-2003-0291:DESCRIPTION:router does not clear information from DHCP packets that have been previously used:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0291::REFERENCE:CVE-2005-1406:DESCRIPTION:Products do not fully clear memory buffers when less data is stored into the buffer than previous.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1406::REFERENCE:CVE-2005-1858:DESCRIPTION:Products do not fully clear memory buffers when less data is stored into the buffer than previous.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1858::REFERENCE:CVE-2005-3180:DESCRIPTION:Products do not fully clear memory buffers when less data is stored into the buffer than previous.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3180::REFERENCE:CVE-2005-3276:DESCRIPTION:Product does not clear a data structure before writing to part of it, yielding information leak of previously used memory.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3276::REFERENCE:CVE-2002-2077:DESCRIPTION:Memory not properly cleared before reuse.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-2077::",::Memory Management::Networking::,::Memory::,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Sensitive Information Uncleared Before Use::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM03-C:ENTRY NAME:Clear sensitive information stored in reusable resources returned for reuse::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP23:ENTRY NAME:Exposed Data::",,"::TYPE:Relationship:NOTE:There is a close association between CWE-226 and CWE-212. The difference is partially that of perspective. CWE-226 is geared towards the final stage of the resource lifecycle, in which the resource is deleted, eliminated, expired, or otherwise released for reuse. Technically, this involves a transfer to a different control sphere, in which the original contents of the resource are no longer relevant. CWE-212, however, is intended for sensitive data in resources that are intentionally shared with others, so they are still active. This distinction is useful from the perspective of the CWE research view (CWE-1000).::TYPE:Maintenance:NOTE:This entry needs modification to clarify the differences with CWE-212. The description also combines two problems that are distinct from the CWE research perspective - the inadvertent transfer of information to another sphere, and improper initialization/shutdown. Some of the associated taxonomy mappings reflect these different uses.::TYPE:Research Gap:NOTE:Currently frequently found for network packets, but it can also exist in local memory allocation, files, etc.::",
276,"Incorrect Default Permissions",Base,Draft,"The product, upon installation, sets incorrect permissions for an object that exposes it to an unintended actor.","",::NATURE:ChildOf:CWE ID:732:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:732:VIEW ID:1003:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Technology-Independent:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Installation::PHASE:Operation::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:IMPACT:Read Application Data:IMPACT:Modify Application Data::","::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Inter-application Flow Analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Host-based Vulnerability Scanners - Examine configuration for flaws, verifying that audit mechanisms work, ensure host configuration meets certain predefined criteria Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Host Application Interface Scanner Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer Automated Monitored Execution Forced Path Execution:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Configuration Checker:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::","::PHASE:Architecture and Design Operation:DESCRIPTION:Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.::PHASE:Architecture and Design:STRATEGY:Separation of Privilege:DESCRIPTION:Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.::","::REFERENCE:CVE-2005-1941:DESCRIPTION:Executables installed world-writable.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1941::REFERENCE:CVE-2002-1713:DESCRIPTION:Home directories installed world-readable.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-1713::REFERENCE:CVE-2001-1550:DESCRIPTION:World-writable log files allow information loss; world-readable file has cleartext passwords.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-1550::REFERENCE:CVE-2002-1711:DESCRIPTION:World-readable directory.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-1711::REFERENCE:CVE-2002-1844:DESCRIPTION:Windows product uses insecure permissions when installing on Solaris (genesis: port error).:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-1844::REFERENCE:CVE-2001-0497:DESCRIPTION:Insecure permissions for a shared secret key file. Overlaps cryptographic problem.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0497::REFERENCE:CVE-1999-0426:DESCRIPTION:Default permissions of a device allow IP spoofing.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-1999-0426::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Insecure Default Permissions::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:FIO06-C:ENTRY NAME:Create files with appropriate access permissions::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:FIO01-J:ENTRY NAME:Create files with appropriate access permission::",::1::127::81::,"",
325,"Missing Required Cryptographic Step",Base,Draft,"The product does not implement a required step in a cryptographic algorithm, resulting in weaker encryption than advertised by that algorithm.","Cryptographic implementations should precisely follow the algorithms that define them, otherwise encryption can be weaker than expected.",::NATURE:ChildOf:CWE ID:573:VIEW ID:1000:ORDINAL:Primary::NATURE:PeerOf:CWE ID:358:VIEW ID:1000::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Technology-Independent:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic. Developers sometimes omit certain expensive (resource-intensive) steps in order to improve performance, especially in devices with limited memory or CPU cycles. This could be done under a mistaken impression that the step is unnecessary for preserving security. Alternately, the developer might adopt a threat model that is inconsistent with that of its consumers by accepting a risk for which the remaining protection seems good enough.::PHASE:Architecture and Design::PHASE:Requirements:NOTE:This issue can be introduced when the requirements for the algorithm are not clearly stated.::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:If the cryptographic algorithm is used for authentication and authorization, then an attacker could gain unauthorized access to the system.::SCOPE:Confidentiality:SCOPE:Integrity:IMPACT:Read Application Data:IMPACT:Modify Application Data:NOTE:Sensitive data may be compromised by the use of a broken or risky cryptographic algorithm.::SCOPE:Accountability:SCOPE:Non-Repudiation:IMPACT:Hide Activities:NOTE:If the cryptographic algorithm is used to ensure the identity of the source of the data (such as digital signatures), then a broken algorithm will compromise this scheme and the source of the data cannot be proven.::","","","::REFERENCE:CVE-2001-1585:DESCRIPTION:Missing challenge-response step allows authentication bypass using public key.:LINK:http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-1585::",::Cryptography::,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Missing Required Cryptographic Step::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A8:ENTRY NAME:Insecure Cryptographic Storage:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A9:ENTRY NAME:Insecure Communications:MAPPING FIT:CWE More Specific::",::68::,"::TYPE:Relationship:NOTE:Overlaps incomplete/missing security check.::TYPE:Relationship:NOTE:Can be resultant.::",
440,"Expected Behavior Violation",Base,Draft,"A feature, API, or function being used by a product behaves differently than the product expects.","",::NATURE:ChildOf:CWE ID:684:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Operation::","",,"::SCOPE:Other:IMPACT:Quality Degradation:IMPACT:Varies by Context::","","","::REFERENCE:CVE-2003-0187:DESCRIPTION:Inconsistency in support of linked lists causes program to use large timeouts on undeserving connections.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0187::REFERENCE:CVE-2003-0465:DESCRIPTION:strncpy in Linux kernel acts different than libc on x86, leading to expected behavior difference - sort of a multiple interpretation error?:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0465::REFERENCE:CVE-2005-3265:DESCRIPTION:Buffer overflow in product stems to the use of a third party library function that is expected to have internal protection against overflows, but doesn't.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3265::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Expected behavior violation::",,"::TYPE:Theoretical:NOTE:The consistency dimension of validity is the most appropriate relevant property of an expected behavior violation. That is, the behavior of the application is not consistent with the expectations of the developer, leading to a violation of the validity property of the software.::",
1053,"Missing Documentation for Design",Base,Incomplete,"The product does not have documentation that represents how it is designed.","This issue can make it more difficult to understand and maintain the product. It can make it more difficult and time-consuming to detect and/or fix vulnerabilities.",::NATURE:ChildOf:CWE ID:1059:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"","","","",,,"",,"",
1189,"Improper Isolation of Shared Resources on System-on-Chip (SoC)",Base,Draft,"The product does not properly isolate shared resources between trusted and untrusted agents.","A System-On-Chip (SoC) has a lot of functionality, but may have a limited number of pins or pads. A pin can only perform one function at a time. However, it can be configured to perform multiple different functions. This technique is called pin multiplexing. Similarly, several resources on the chip may be shared to multiplex and support different features or functions. When such resources are shared between trusted and untrusted agents, untrusted agents may be able to access the assets intended to be accessed only by the trusted agents.",::NATURE:ChildOf:CWE ID:668:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:If shared resources are being used by a trusted user, it may be possible for untrusted agents to modify the functionality of the shared resource for the trusted user.::SCOPE:Integrity:IMPACT:Quality Degradation:NOTE:The functionality of the shared resource may be intentionally degraded.::","::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:Kernel integrity verification can help identify when shared resource configuration settings have been modified.:EFFECTIVENESS:High::","::PHASE:Architecture and Design:STRATEGY:Separation of Privilege:DESCRIPTION:When sharing resources, avoid mixing agents of varying trust levels. Group untrusted agents together to access when sharing a resource. Similarly, group trusted agents (at same trust level).::","",,,"",,"",
1190,"DMA Device Enabled Too Early in Boot Phase",Base,Draft,"The product enables a Direct Memory Access (DMA) capable device before the security configuration settings are established, which allows an attacker to extract data from or gain privileges on the product.","DMA is included in a number of devices because it allows data transfer between the computer and the connected device, using direct hardware access to read or write directly to main memory without any OS interaction. An attacker could exploit this to access secrets. Several virtualization-based mitigations have been introduced to thwart DMA attacks. These are usually configured/setup during boot time. However, certain IPs that are powered up before boot is complete (known as early boot IPs) may be DMA capable. Such IPs, if not trusted, could launch DMA attacks and gain access to assets that should otherwise be protected.",::NATURE:ChildOf:CWE ID:696:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:IMPACT:Modify Memory:LIKELIHOOD:High:NOTE:DMA devices have direct write access to main memory and due to time of attack will be able to bypass OS or Bootloader access control.::","","::PHASE:Architecture and Design:DESCRIPTION:Utilize an IOMMU to orchestrate IO access from the start of the boot process.::","",,,"",,"",
1191,"Exposed Chip Debug Interface With Insufficient Access Control",Base,Draft,"The chip does not implement or does not correctly enforce access control on the debug interface, thus allowing an attacker to exercise the debug interface to access a portion of the chip internal registers that typically would not be exposed.","Integrated circuits can expose the chip internals through a scan chain interconnected through internal registers etc., through scan flip-flops. A Joint Test Action Group (JTAG) compatible test access port usually provides access to this scan chain for debugging the chip. Since almost every asset in the chip can be accessed over this debug interface, chip manufacturers typically insert some form of password-based or challenge-response based access control mechanisms to prevent misuse. This mechanism is implemented in addition to on-chip protections that are already present. If this debug access control is not implemented or the access control check is not implemented properly, or if the hardware does not clear secret keys, etc., when debug more is entered, an attacker may be able to bypass on-chip access control mechanisms through debug features/interfaces.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:LIKELIHOOD:High::","","::PHASE:Architecture and Design:STRATEGY:Separation of Privilege:DESCRIPTION:Implement an access control mechanism to exercise the debug interface in order to control and observe security-sensitive chip internals. Password checking logic should be resistant to timing attacks. Security-sensitive data stored in registers, such as keys, etc. should be cleared when entering debug mode.::","::REFERENCE:CVE-2019-18827:DESCRIPTION:chain: JTAG interface is not disabled (CWE-1191) during ROM code execution, introducing a race condition (CWE-362) to extract encryption keys:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18827::",,,"",,"",
1192,"System-on-Chip (SoC) Using Components without Unique, Immutable Identifiers",Base,Draft,"The System-on-Chip (SoC) does not have unique, immutable identifiers for each of its components.","A System-on-Chip (SoC) comprises several components (IP) with varied trust requirements. It is required that each IP is identified uniquely and should distinguish itself from other entities in the SoC without any ambiguity. The unique secured identity is required for various purposes. Most of the time the identity is used to route a transaction or perform certain actions (i.e. resetting, retrieving a sensitive information, and acting upon or on behalf of), etc. There are several variants of this weakness: A missing identifier is when the SoC does not define any mechanism to uniquely identify the IP. An insufficient identifier might provide some defenses - for example, against the most common attacks - but it does not protect against everything that is intended. A misconfigured mechanism occurs when a mechanism is available but not implemented correctly. An ignored identifier occurs when the SoC/IP has not applied any policies or does not act upon the identifier securely.",::NATURE:ChildOf:CWE ID:657:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Operation::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:LIKELIHOOD:High::","","::PHASE:Architecture and Design:STRATEGY:Separation of Privilege:DESCRIPTION:Every identity generated in the SoC should be unique and immutable in hardware. The actions that an IP is trusted or not trusted should be clearly defined, implemented, configured, and tested. If the definition is implemented via a policy, then the policy should be immutable or protected with clear authentication and authorization.::","",,,"",,"",
1193,"Power-On of Untrusted Execution Core Before Enabling Fabric Access Control",Base,Draft,"The product enables components that contain untrusted firmware before memory and fabric access controls have been enabled.","After initial reset, System-on-Chip (SoC) fabric access controls and other security features need to be programmed by trusted firmware as part of the boot sequence. If untrusted IPs or peripheral microcontrollers are enabled first, then the untrusted component can master transactions on the hardware bus and target memory or other assets to compromise the SoC boot firmware.",::NATURE:ChildOf:CWE ID:696:VIEW ID:1000:ORDINAL:Primary::,"",,"","","","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:LIKELIHOOD:High:NOTE:An untrusted component can master transactions on the HW bus and target memory or other assets to compromise the SoC boot firmware.::","","::PHASE:Architecture and Design:DESCRIPTION:The boot sequence should enable fabric access controls and memory protections before enabling third-party hardware IPs and peripheral microcontrollers that use untrusted firmware.::","",,,"",,"",
1209,"Failure to Disable Reserved Bits",Base,Incomplete,"The reserved bits in a hardware design are not disabled prior to production. Typically, reserved bits are used for future capabilities and should not support any functional logic in the design. However, designers might covertly use these bits to debug or further develop new capabilities in production hardware. Adversaries with access to these bits will write to them in hopes of compromising hardware state.","Reserved bits are labeled as such so they can be allocated for a later purpose. They are not to do anything in the current design. However, designers might want to use these bits to debug or control/configure a future capability to help minimize time to market (TTM). If the logic being controlled by these bits is still enabled in production, an adversary could use the logic to induce unwanted/unsupported behavior in the hardware.",::NATURE:ChildOf:CWE ID:710:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Architecture-Independent:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:The Designer and Implementer have to make a conscious choice to do this::PHASE:Implementation:NOTE:The Designer and Implementer have to make a conscious choice to do this::PHASE:Documentation:NOTE:If documentation labels anything for future use, reserved, or the like, such labeling could indicate to an attacker a potential attack point::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:SCOPE:Accountability:SCOPE:Authentication:SCOPE:Authorization:SCOPE:Non-Repudiation:IMPACT:Varies by Context:NOTE:This type of weakness all depends on the capabilities of the logic being controlled or configured by the reserved bits::","","::PHASE:Architecture and Design Implementation:DESCRIPTION:Include a feature disable::PHASE:Integration:DESCRIPTION:Any writes to these reserve bits are blocked (e.g., ignored, access-protected, etc.), or an exception can be asserted.::","",,,"",,"",
1220,"Insufficient Granularity of Access Control",Base,Incomplete,"The product implements access controls via a policy or other feature with the intention to disable or restrict accesses (reads and/or writes) to assets in a system from untrusted agents. However, implemented access controls lack required granularity, which renders the control policy too broad because it allows accesses from unauthorized agents to the security-sensitive assets.","Integrated circuits and hardware engines can expose accesses to assets (device configuration, keys, etc.) to trusted firmware or a software module (commonly set by BIOS/bootloader). This access is typically access-controlled. Upon a power reset, the hardware or system usually starts with default values in registers, and the trusted firmware (Boot firmware) configures the necessary access-control protection. A common weakness that can exist in such protection schemes is that access controls or policies are not granular enough. This condition allows agents beyond trusted agents to access assets and could lead to a loss of functionality or the ability to set up the device securely. This further results in security risks from leaked, sensitive, key material to modification of device configuration.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Architecture-Independent:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Technology-Independent:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:Such issues could be introduced during hardware implementation and identified later during Testing or System Configuration phases.::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:IMPACT:Modify Memory:IMPACT:Read Memory:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Gain Privileges or Assume Identity:IMPACT:Bypass Protection Mechanism:IMPACT:Other:LIKELIHOOD:High::","","::PHASE:Architecture and Design Implementation Testing:DESCRIPTION:Access-control-policy protections must be reviewed for design inconsistency and common weaknesses. Access-control-policy definition and programming flow must be tested in pre-silicon, post-silicon testing.:EFFECTIVENESS:High::","",,,"",,"",
1221,"Incorrect Register Defaults or Module Parameters",Base,Incomplete,"Hardware description language code incorrectly defines register defaults or hardware IP parameters to insecure values.","Integrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to defined default values that are hard coded in the hardware description language (HDL) code of the hardware unit. Hardware descriptive languages also support definition of parameter variables, which can be defined in code during instantiation of the hardware IP module. Such parameters are generally used to configure a specific instance of a hardware IP in the design. The system security settings of a hardware design can be affected by incorrectly defined default values or IP parameters. The hardware IP would be in an insecure state at power reset, and this can be exposed or exploited by untrusted software running on the system. Both register defaults and parameters are hardcoded values, which cannot be changed using software or firmware patches but must be changed in hardware silicon. Thus, such security issues are considerably more difficult to address later in the lifecycle. Hardware designs can have a large number of such parameters and register defaults settings, and it is important to have design tool support to check these settings in an automated way and be able to identify which settings are security sensitive.",::NATURE:ChildOf:CWE ID:665:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE NAME:Verilog:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:VHDL:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Technology-Independent:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Implementation:NOTE:Such issues could be introduced during implementation of hardware design, since IP parameters and defaults are defined in HDL code and identified later during Testing or System Configuration phases.::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:IMPACT:Varies by Context:NOTE:Degradation of system functionality, or loss of access control enforcement::","","::PHASE:Architecture and Design:DESCRIPTION:During hardware design all the system parameters and register defaults must be reviewed to identify security sensitive settings::PHASE:Implementation:DESCRIPTION:The default values of these security sensitive settings need to be defined as part of the design review phase.::PHASE:Testing:DESCRIPTION:Testing phase should use automated tools to test that values are configured per design specifications.::","",,,"",,"",
1223,"Race Condition for Write-Once Attributes",Base,Incomplete,"A write-once register in hardware design is programmable by an untrusted software component earlier than the trusted software component, resulting in a race condition issue.","Integrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to defined default values that are hard coded in the hardware description language (HDL) code of the hardware unit. A common security protection method used to protect register settings from modification by software is to make them write-once. This means the hardware implementation only allows writing to such registers once, and they become read-only after having been written once by software. This is useful to allow initial boot software to configure systems settings to secure values while blocking runtime software from modifying such hardware settings. Implementation issues in hardware design of such controls can expose such registers to a race condition security flaw. For example, consider a hardware design that has two different software/firmware modules executing in parallel. One module is trusted (module A) and another is untrusted (module B). In this design it could be possible for Module B to send write cycles to the write-once register before Module A. Since the field is write-once the programmed value from Module A will be ignored and the pre-empted value programmed by Module B will be used by hardware.",::NATURE:ChildOf:CWE ID:362:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE NAME:Verilog:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:VHDL:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:This weakness can appear in designs that use register write-once attributes with two or more software/firmware modules with varying levels of trust executing in parallel.::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:System configuration cannot be programmed in a secure way::","","::PHASE:Architecture and Design:DESCRIPTION:During hardware design all register write-once or sticky fields must be evaluated for proper configuration.::PHASE:Testing:DESCRIPTION:The testing phase should use automated tools to test that values are not reprogrammable and that write-once fields lock on writing zeros.::","",,,"",,"",
1224,"Improper Restriction of Write-Once Bit Fields",Base,Incomplete,"The hardware design control register sticky bits or write-once bit fields are improperly implemented, such that they can be reprogrammed by software.","Integrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to define default values that are hard coded in the hardware description language (HDL) code of the hardware unit. A common security protection method used to protect register settings from modification by software is to make the settings write-once or sticky. This allows writing to such registers only once, whereupon they become read-only. This is useful to allow initial boot software to configure systems settings to secure values while blocking runtime software from modifying such hardware settings. Failure to implement write-once restrictions in hardware design can expose such registers to being re-programmed by software and written multiple times. For example, write-once fields could be implemented to only be write-protected if they have been set to value 1, wherein they would work as write-1-once and not write-once.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE NAME:Verilog:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:VHDL:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation:NOTE:Such issues could be introduced during implementation of hardware design, since IP parameters and defaults are defined in HDL code and identified later during Testing or System Configuration phases.::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:IMPACT:Varies by Context:NOTE:System configuration cannot be programmed in a secure way::","","::PHASE:Architecture and Design:DESCRIPTION:During hardware design all register write-once or sticky fields must be evaluated for proper configuration.::PHASE:Testing:DESCRIPTION:The testing phase should use automated tools to test that values are not reprogrammable and that write-once fields lock on writing zeros.::","",,,"",,"",
1231,"Improper Implementation of Lock Protection Registers",Base,Incomplete,"The product incorrectly implements register lock bit protection features such that protected controls can be programmed even after the lock has been set.","In integrated circuits and hardware IPs, device configuration controls are commonly programmed after a device power reset by a trusted firmware or software module (e.g., BIOS/bootloader) and then locked from any further modification. This is commonly implemented using a trusted lock bit, which when set disables writes to a protected set of registers or address regions. Design or coding errors in the implementation of the lock bit protection feature may allow the lock bit to be modified or cleared by software after being set to unlock the system.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Architecture-Independent:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Technology-Independent:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:Such issues could be introduced during implementation and identified later during Testing or System Configuration phases.::","",,"::SCOPE:Access Control:IMPACT:Modify Memory:LIKELIHOOD:High:NOTE:Registers protected by lock bit can be modified even when lock is set.::","","::PHASE:Architecture and Design Implementation Testing:DESCRIPTION:Security lock bit protections must be reviewed for design inconsistency and common weaknesses. Security lock programming flow and lock properties must be tested in pre-silicon, post-silicon testing.:EFFECTIVENESS:High::","",,,"",,"",
1232,"Improper Lock Behavior After Power State Transition",Base,Incomplete,"The product implements register lock bit protection features with the intent to disable changes to system configuration after the lock is set. Some of the protected registers or lock bits become programmable after power state transitions (e.g., Entry and wake from low power sleep modes).","Integrated circuits and hardware IPs can expose the device configuration controls that need to be programmed after device power reset by a trusted firmware or software module (commonly set by BIOS/bootloader) and then locked from any further modification. In hardware design this is commonly implemented using a programmable lock bit, which when set disables writes to a protected set of registers or address regions. Some common weaknesses that can exist in such a protection scheme is that the lock gets cleared, the values of the protected registers get reset, or the lock become programmable after a power state transition.",::NATURE:ChildOf:CWE ID:667:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Architecture-Independent:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Technology-Independent:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design or implementation and identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:Such issues could be introduced during hardware architecture and design or implementation and identified later during Testing or System Configuration phases.::","",,"::SCOPE:Access Control:IMPACT:Modify Memory:LIKELIHOOD:High:NOTE:System Configuration protected by lock bit can be modified even when lock is set.::","","::PHASE:Architecture and Design Implementation Testing:DESCRIPTION:Security Lock bit protections must be reviewed for behavior across supported power state transitions. Security lock programming flow and lock properties must be tested in pre-si, post-si testing, including testing these across power transitions.:EFFECTIVENESS:High::","",,,"",,"",
1233,"Improper Hardware Lock Protection for Security Sensitive Controls",Base,Incomplete,"The product implements a register lock bit protection feature that permits security sensitive controls to modify the protected configuration.","Integrated circuits and hardware IPs can expose the device configuration controls that need to be programmed after device power reset by a trusted firmware or software module (commonly set by BIOS/bootloader) and then locked from any further modification. This is commonly implemented using a trusted lock bit, which when set disables writes to a protected set of registers or address regions. The lock protection is intended to prevent modification of certain system configuration (e.g., memory/memory protection unit configuration). If any system registers/controls that can modify the protected configuration are not write-protected by the lock, they can then be leveraged by software to modify the protected configuration.",::NATURE:ChildOf:CWE ID:667:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Architecture-Independent:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Technology-Independent:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:Such issues could be introduced during implementation and identified later during Testing or System Configuration phases.::","",,"::SCOPE:Access Control:IMPACT:Modify Memory:NOTE:System Configuration protected by the lock bit can be modified even when the lock is set.::","","::PHASE:Architecture and Design Implementation Testing:DESCRIPTION:Security lock bit protections must be reviewed for design inconsistency and common weaknesses. Security lock bit protections must be reviewed common weaknesses. Security lock programming flow and lock properties must be tested in pre-si, post-si testing.::","",,,"",,"",
1234,"Hardware Internal or Debug Modes Allow Override of Locks",Base,Incomplete,"The product implements register lock bit protection features that may permit security sensitive controls to modify system configuration after the lock is set through internal modes or debug features.","In integrated circuits and hardware IPs, device configuration controls are commonly programmed after a device power reset by a trusted firmware or software module (e.g., BIOS/bootloader) and then locked from any further modification. This is commonly implemented using a trusted lock bit, which when set disables writes to a protected set of registers or address regions. The lock protection is intended to prevent modification of certain system configuration (e.g., memory/memory protection unit configuration). If debug features supported by hardware or internal modes/system states are supported in the hardware design, they may allow modification of the lock protection.",::NATURE:ChildOf:CWE ID:667:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Architecture-Independent:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Technology-Independent:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:Such issues could be introduced during implementation and identified later during Testing or System Configuration phases.::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:LIKELIHOOD:High:NOTE:System Configuration protected by lock bit can be modified even when lock is set.::","","::PHASE:Architecture and Design Implementation Testing:DESCRIPTION:Security Lock bit protections must be reviewed for any bypass/override modes supported. Any supported override modes either must be removed, or these modes should be protected using features like secure authenticated, authorized debug modes. Security lock programming flow and lock properties must be tested in pre-si, post-si testing.:EFFECTIVENESS:High::","",,,"",,"",
1240,"Use of a Risky Cryptographic Primitive",Base,Draft,"The product implements a cryptographic algorithm using a non-standard or unproven cryptographic primitive.","Cryptographic algorithms (or Cryptographic systems) depend on cryptographic primitives as their basic building blocks. As a result, cryptographic primitives are designed to do one very specific task in a precisely defined and highly reliable fashion. For example, one can declare that a specific crypto primitive (like an encryption routine) can only be broken after trying out N different inputs (the larger the value of N, the stronger the crypto). If a vulnerability is found that leads to breaking this primitive in significantly less than N attempts, then the specific cryptographic primitive is considered broken, and the entirety of the cryptographic algorithm (or the cryptographic system) is now considered insecure. Thus, even breaking a seemingly small cryptographic primitive is sufficient to render the whole system vulnerable. Cryptographic primitives are products of extensive reviews from cryptographers, industry, and government entities looking for any possible flaws. However, over time even well-known cryptographic primitives lose their compliance status with emergence of novel attacks that might either defeat the algorithm or reduce its robustness significantly. If ad-hoc cryptographic primitives are implemented, it is almost certain that such implementation will be vulnerable to attacks resulting in the exposure of sensitive information and/or other consequences.",::NATURE:ChildOf:CWE ID:327:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Architecture-Independent:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"::This issue is even more prominent for hardware-implemented deployment of cryptographic algorithms due to a number of reasons. Firstly, because hardware is not replaceable like software, if a flaw is discovered with a hardware-implemented cryptographic primitive, it cannot be fixed in most cases without a recall of the product. Secondly, the hardware product is often expected to work for years, during which time computation power available to the attacker only increases. Therefore, for hardware implementations of cryptographic primitives, it is absolutely essential that only strong, proven cryptographic primitives are used.::","","::PHASE:Architecture and Design:NOTE:This weakness is primarily introduced during the architecture and design phase as risky primitives are included.::PHASE:Implementation:NOTE:In many cases, the design originally defines a proper cryptography primative, but this is then changed during implementation due to unforseen constraints.::","",,"::SCOPE:Confidentiality:IMPACT:Read Application Data:LIKELIHOOD:High:NOTE:Incorrect usage of crypto primitives could render the supposedly encrypted data as unencrypted plaintext in the worst case. This would compromise any security property, including the ones listed above.::","","::PHASE:Architecture and Design:DESCRIPTION:Follow these good cryptography practices: Do not create your own crypto algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature. As with all cryptographic mechanisms, the source code should be available for analysis. If the algorithm can be compromised when attackers find out how it works, then it is especially weak. Do not use outdated/not-compliant cryptography algorithms. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. Do not use LFSR as a substitute for proper Random Number Generator IPs. Do not use checksum as a substitute for proper Hashes. Design the hardware at the IP level so that one cryptographic algorithm can be replaced with another in the next generation. Use wrappers to make the interfaces uniform. This will make it easier to upgrade to stronger algorithms. Do not store keys in areas accessible to untrusted agents. Carefully manage and protect cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant. Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Industry-standard implementations will save development time and might be more likely to avoid errors that can occur during implementation of cryptographic algorithms. When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.:EFFECTIVENESS:High::","",,,"",,"",
1241,"Use of Predictable Algorithm in Random Number Generator",Base,Draft,"The product requires a true random number but uses an algorithm that is predictable and generates a pseudo-random number.","",::NATURE:ChildOf:CWE ID:330:VIEW ID:1000:ORDINAL:Primary::,"",::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:This weakness is primarily introduced during the architecture and design phase an incorrect algorithm is defined.::PHASE:Implementation:NOTE:In many cases, the design originally defines a proper cryptography primative, but this is then changed during implementation due to unforseen constraints.::","",,"::SCOPE:Confidentiality:IMPACT:Read Application Data:LIKELIHOOD:High:NOTE:Predicatable random numbers can render the protection mechanisms in place ineffective::","","::PHASE:Architecture and Design:DESCRIPTION:Leverage well-known true random number generation techniques.:EFFECTIVENESS:High::","",,,"",,"",
1242,"Inclusion of Undocumented Features or Chicken Bits",Base,Incomplete,"The chip includes chicken bits or undocumented features that can create entry points for unauthorized actors.","A common design practice is to use chicken bits, which are bits on a chip that can be used to disable certain functional security features. They can facilitate quick identification and isolation of faulty components, features that negatively affect performance, or features that do not provide the required controllability for debug and test. Another way to achieve this is through implementation of undocumented features. An attacker might exploit these interfaces for unauthorized access.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Architecture-Independent:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Documentation::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:IMPACT:Modify Memory:IMPACT:Read Memory:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Gain Privileges or Assume Identity:IMPACT:Bypass Protection Mechanism::","","::PHASE:Architecture and Design Implementation:DESCRIPTION:Do not implement chicken bits. If implemented, ensure that they are disabled in production devices. Document all interfaces to the chip.:EFFECTIVENESS:High::","",,,"",,"",
1243,"Exposure of Security-Sensitive Fuse Values During Debug",Base,Incomplete,"The product exposes security-sensitive values stored in fuses during debug.","Several security-sensitive values are blown as fuses in a chip to be used during early-boot flows or later at runtime. Examples of these security-sensitive values include root keys, encryption keys, manufacturing-specific information, chip-manufacturer-specific information, and original-equipment-manufacturer (OEM) data. After the chip is powered on, these values are sensed from fuses and stored in temporary locations such as registers and local memories. These locations are typically access-control protected from untrusted agents capable of accessing them. Even to trusted agents, only read-access is provided. However, these locations are not blocked during debug flows, allowing an untrusted debugger to access these assets and compromise system security.",::NATURE:ChildOf:CWE ID:200:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Architecture-Independent:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Confidentiality:SCOPE:Access Control:IMPACT:Modify Memory:IMPACT:Bypass Protection Mechanism::","","::PHASE:Architecture and Design Implementation:DESCRIPTION:When in debug mode, disable access to security-sensitive values sensed from fuses and stored in temporary locations.::","",,,"",,"",
1244,"Improper Authorization on Physical Debug and Test Interfaces",Base,Incomplete,"The product's physical debug and test interface protection does not block untrusted agents, resulting in unauthorized access to and potentially control of sensitive assets.","If the product implements access-control protection on the debug and test interface, a debugger is typically required to enter either a valid response to a challenge provided by the authorization logic or, alternatively, enter the right password in order to exercise the debug and test interface. However, if this protection mechanism does not exclude all untrusted, debug agents, an attacker could access/control security-sensitive registers.",::NATURE:ChildOf:CWE ID:285:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Architecture-Independent:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Confidentiality:IMPACT:Read Memory::SCOPE:Integrity:IMPACT:Modify Memory::SCOPE:Authorization:SCOPE:Access Control:IMPACT:Gain Privileges or Assume Identity:IMPACT:Bypass Protection Mechanism::","","::PHASE:Architecture and Design Implementation:DESCRIPTION:For security-sensitive assets accessible over debug/test interfaces, only allow trusted agents.::","::REFERENCE:CVE-2019-18827:DESCRIPTION:JTAG access is disabled after ROM code execution. This means that JTAG access is possible when the system is running code from ROM before transferring control over to embedded firmware. This allows an attacker to modify boot flow and successfully bypass secure-boot process.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18827::",,,"",,"",
1245,"Improper Finite State Machines (FSMs) in Hardware Logic",Base,Incomplete,"Faulty finite state machines (FSMs) in the hardware logic allow an attacker to put the system in an undefined state, to cause a denial of service (DoS) or gain privileges on the victim's system.","The functionality and security of the system heavily depend on the implementation of FSMs. FSMs can be used to indicate the current security state of the system. Lots of secure data operations and data transfers rely on the state reported by the FSM. Faulty FSM designs that do not account for all states, either through undefined states (left as don't cares) or through incorrect implementation, might lead an attacker to drive the system into an unstable state from which the system cannot recover without a reset, thus causing a DoS. Depending on what the FSM is used for, an attacker might also gain additional privileges to launch further attacks and compromise the security guarantees.",::NATURE:ChildOf:CWE ID:684:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Architecture-Independent:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Availability:SCOPE:Access Control:IMPACT:Unexpected State:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:DoS: Instability:IMPACT:Gain Privileges or Assume Identity::","","::PHASE:Architecture and Design Implementation:DESCRIPTION:Define all possible states and handle all unused states through default statements. Ensure that system defaults to a secure state.:EFFECTIVENESS:High::","",,,"",,"",
1246,"Improper Write Handling in Limited-write Non-Volatile Memories",Base,Incomplete,"The product does not implement or incorrectly handles the implementation of write operations in limited-write non-volatile memories.","Non-volatile memories such as NAND Flash, EEPROM, etc. have individually erasable segments, each of which can be put through a limited number of program/erase or write cycles. For example, the device can only endure a limited number of writes, after which the device becomes unreliable. In order to wear out the cells in a uniform manner, non-volatile memory and storage products based on the above-mentioned technologies implement a technique called wear leveling. Once a set threshold is reached, wear leveling maps writes of a logical block to a different physical block. This prevents a single physical block from prematurely failing due to a high concentration of writes. If wear leveling is improperly implemented, attackers can execute a write virus and cause the storage to become unreliable much faster than the minimally guaranteed platform lifetime.",::NATURE:ChildOf:CWE ID:664:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Architecture-Independent:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Memory IP:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Storage IP:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Availability:IMPACT:DoS: Instability::","","::PHASE:Architecture and Design Implementation Testing:DESCRIPTION:Include secure wear leveling algorithms and ensure that it cannot be bypassed by known write viruses.:EFFECTIVENESS:High::","",,,"",,"",
1247,"Missing Protection Against Voltage and Clock Glitches",Base,Incomplete,"The product does not contain the necessary additional circuitry or sensors to detect and mitigate voltage and clock glitches.","A product might support security features such as secure boot that are supported through hardware and firmware implementation. This involves establishing a chain of trust, starting with an immutable root of trust by checking the signature of the next stage (culminating with the OS and runtime software) against a golden value before transferring control. The intermediate stages typically set up the system in a secure state by configuring several access control settings. Similarly, any password-checking logic for exercising the debug interface, etc. can implemented in hardware, firmware, or both. This implementation needs to be robust against fault attacks such as voltage glitches and clock glitches that an attacker may leverage to compromise the system.",::NATURE:ChildOf:CWE ID:703:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Architecture-Independent:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Power Management IP:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Clock/Counter IP:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Sensor IP:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Operation::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:IMPACT:Gain Privileges or Assume Identity:IMPACT:Bypass Protection Mechanism:IMPACT:Read Memory:IMPACT:Modify Memory:IMPACT:Execute Unauthorized Code or Commands::","","::PHASE:Architecture and Design Implementation:DESCRIPTION:At the circuit-level, using Tunable Replica Circuits (TRCs) or special flip-flops such as Razor flip-flops helps mitigate glitches. At SoC or platform level, level sensors can be implemented to detect glitches. Implementing redundancy in security-sensitive code (e.g., where checks are performed) helps in mitigating glitches.::","::REFERENCE:CVE-2019-17391:DESCRIPTION:Lack of anti-glitch protections allows an attacker to launch physical attack to bypass secure boot and read protected eFuses.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-17391::",,,"",,"",
1248,"Semiconductor Defects in Hardware Logic with Security-Sensitive Implications",Base,Incomplete,"The security-sensitive hardware module contains semiconductor defects.","A semiconductor device can fail for various reasons. While some are manufacturing and packaging defects, the rest are due to prolonged use or usage under extreme conditions. Some mechanisms that lead to semiconductor defects include encapsulation failure, die-attach failure, wire-bond failure, bulk-silicon defects, oxide-layer faults, aluminum-metal faults (including electromigration, corrosion of aluminum, etc.), and thermal/electrical stress. These defects manifest as faults on chip-internal signals or registers, have the effect of inputs, outputs, or intermediate signals being always 0 or always 1, and do not switch as expected. If such faults occur in security-sensitive hardware modules, security guarantees offered by the device will be compromised.",::NATURE:ChildOf:CWE ID:693:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Architecture-Independent:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Technology-Independent:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Manufacturing::PHASE:Operation::","",,"::SCOPE:Availability:SCOPE:Access Control:IMPACT:DoS: Instability::","","::PHASE:Testing:DESCRIPTION:While semiconductor-manufacturing companies implement several mechanisms to continuously improve the semiconductor manufacturing process to ensure reduction of defects, some defects can only be fixed after manufacturing. Post-manufacturing testing of silicon die is critical. Fault models such as stuck-at-0 or stuck-at-1 must be used to develop post-manufacturing test cases and achieve good coverage. Once the silicon packaging is done, extensive post-silicon testing must be performed to ensure that hardware logic implementing security functionalities is defect-free.::PHASE:Operation:DESCRIPTION:Operating the hardware outside device specification, such as at extremely high temperatures, voltage, etc., accelerates semiconductor degradation and results in defects. When these defects manifest as faults in security-critical, hardware modules, it results in compromise of security guarantees. Thus, operating the device within the specification is important.::","",,,"",,"",
1251,"Mirrored Regions with Different Values",Base,Incomplete,"The product's architecture mirrors regions without ensuring that their contents always stay in sync.","Having mirrored regions with different values might result in the exposure of sensitive information and/or other consequences, including loss of access control. Due to architectural and performance constraints, one might need to duplicate a resource. The most common example of doing this in computer architecture is the concept of cache, which keeps a local copy of the data element in memory, because the time to access the memory (which is located far off from the computing core) is significantly longer compared to the time it takes to access a local copy (cache). Thus, keeping a local copy of some distant entity provides significant performance improvement. Unfortunately, this improvement also comes with a downside, since the product needs to ensure that the local copy always mirrors the original copy truthfully. If they get out of sync somehow, the computational result is no longer true. In designing hardware, memory is not the only thing that gets mirrored. There are many other entities that get mirrored, too: registers, memory regions, and, in some cases, even whole units. For example, for a multi-core processor, if every memory access from any of those tens of cores goes through a single memory-management unit (MMU) for security reasons, then the MMU becomes a performance bottleneck. In such cases, it might make sense to create duplicate, local MMUs that will serve only a subset of the cores of processors rather than all of them. These local copies are also called shadow copies or mirrored copies. If the original resource that was being duplicated into these local copies never changed, the question of the local copies getting out of sync would not arise. Unfortunately, in many cases, the values inside the original copy change. For example, a memory range might be inaccessible during boot time, but once the boot process is over and the system is now in a stable state, that memory range may now be opened up for access. So, if a register(s) in the access-control unit stores the start and end addresses of the accessible memory chunks, those values would change after the boot process is over. Now, when the original copy changes, the mirrored copies must also change, and change fast. This situation of shadow-copy-possibly-out-of-sync-with-original-copy might occur as a result of multiple scenarios, including the following: After the values in the original copy change, due to some reason the original copy does not send the update request to its shadow copies. After the values in the original copy change, the original copy dutifully sends the update request to its shadow copies, but due to some reason the shadow copy does not execute this update request. After the values in the original copy change, the original copy sends the update request to its shadow copies, and the shadow copy executes this update request faithfully. However, during the small time period when the original copy has new values and the shadow copy is still holding the old values, an attacker can exploit the old values. Then it becomes a race condition between the attacker and the update process of who can reach the target, shadow copy first, and, if the attacker reaches first, the attacker wins. The attacker might send a spoofed update request to the target shadow copy, pretending that this update request is coming from the original copy. This spoofed request might cause the targeted shadow copy to update its values to some attacker-friendly values, while the original copies remain unchanged by the attacker. Suppose a situation where the original copy has a system of reverting back to its original value if it does not hear back from all the shadow copies that such copies have successfully completed the update request. In such a case, an attack might occur as follows: (1) the original copy might send an update request; (2) the shadow copy updates it; (3) the shadow copy sends back the successful completion message; (4) through a separate issue, the attacker is able to intercept the shadow copy's completion message. In this case, the original copy thinks that the update did not succeed, hence it reverts to its original value. Now there is a situation where the original copy has the old value, and the shadow copy has the new value.",::NATURE:ChildOf:CWE ID:1250:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE NAME:VHDL:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:Verilog:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Architecture-Independent:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY NAME:Security IP:TECHNOLOGY PREVALENCE:Undetermined::,"","","","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:SCOPE:Accountability:SCOPE:Authentication:SCOPE:Authorization:SCOPE:Non-Repudiation:IMPACT:Varies by Context::","","::PHASE:Architecture and Design:DESCRIPTION:Whenever there are multiple, physically different copies of the same value that might change and the process to update them is not instantaneous and atomic, it is impossible to assert that the original and shadow copies will always be in sync - there will always be a time period when they are out of sync. To mitigate the consequential risk, the recommendations essentially are: Make this out-of-sync time period as small as possible, and Make the update process as robust as possible.:EFFECTIVENESS:Moderate::","",,,"",,"::TYPE:Research Gap:NOTE:Issues related to state and cache - creation, preservation, and update - are a significant gap in CWE that is expected to be addressed in future versions. It likely has relationships to concurrency and synchronization, incorrect behavior order, and other areas that already have some coverage in CWE, although the focus has typically been on independent processes on the same operating system - not on independent systems that are all a part of a larger system-of-systems.::",
1252,"CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations",Base,Incomplete,"The CPU is not configured to provide hardware support for exclusivity of write and execute operations on memory. This allows an attacker to execute data from all of memory.","CPUs provide a special bit that supports exclusivity of write and execute operations. This bit is used to segregate areas of memory to either mark them as code (instructions, which can be executed) or data (which should not be executed). In this way, if a user can write to a region of memory, the user cannot execute from that region and vice versa. This exclusivity provided by special hardware bit is leveraged by the operating system to protect executable space. While this bit is available in most modern processors by default, in some CPUs the exclusivity is implemented via a memory-protection unit (MPU) and memory-management unit (MMU) in which memory regions can be carved out with exact read, write, and execute permissions. However, if the CPU does not have an MMU/MPU, then there is no write exclusivity. Without configuring exclusivity of operations via segregated areas of memory, an attacker may be able to inject malicious code onto memory and later execute it.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Architecture-Independent:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY NAME:Microcontroller IP:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Processor IP:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:IMPACT:Execute Unauthorized Code or Commands::","","::PHASE:Architecture and Design:DESCRIPTION:Implement a dedicated bit that can be leveraged by the Operating System to mark data areas as non-executable. If such a bit is not available in the CPU, implement MMU/MPU (memory management unit / memory protection unit).::PHASE:Integration:DESCRIPTION:If MMU/MPU are not available, then the firewalls need to be implemented in the SoC interconnect to mimic the write-exclusivity operation.::","",,,"",,"",
